---
layout: post
title: Korn Shell Notes(IV)
categories:
 - Unix/Linux
tags:
 - Shell
 - Unix/Linux
 - Notes
status: publish
type: post
published: true
meta:
  views: '93'
  original_post_id: '47'
  _wp_old_slug: '47'
author: 
---

<div id="yn69" style="padding:1em 0;text-align:left;">
<h2><i><span style="font-family:'Courier New';"><span style="font-family:Verdana;">16 The Environment</span></span></i><br />
</h2>
<h2>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h2>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></p>
<div id="i4_8" style="padding:1em 0;text-align:center;">
<img src="http://docs.google.com/File?id=dd6nw3mt_168dd38bmfm_b" style="width:472px;height:714px;" />
</div>
<p></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></p>
<div id="i4_8" style="padding:1em 0;text-align:left;">
<h3><a id="16_1_CDPATH_5651453254671944_6_11823947909311716" name="16_1_CDPATH_5651453254671944_6_11823947909311716"></a><br />
 16.1 CDPATH<br />
 </h3>
<p> The <b>CDPATH</b><br />
variable is provided to make directory navigation easier. It contains a<br />
list of colon-separated directories to check when a full pathname is<br />
not given to the cd command. Each directory in CDPATH is searched from<br />
left-to-right for a directory that matches the cd argument. A : alone<br />
in CDPATH stands for the current directory.</p>
<h3><a id="16_2_PATH_2677888549093702_009_6379903118402938" name="16_2_PATH_2677888549093702_009_6379903118402938"></a><br />
 16.2 PATH<br />
 </h3>
<p> The <b>PATH</b><br />
variable contains a list of colon-separated directories to check when a<br />
command is invoked. Each directory in PATH is searched from<br />
left-to-right for a file whose name matches the command name. If not<br />
found, an error message is displayed. A : alone in PATH specifies to<br />
check the current directory.</p>
<h3><a id="16_3_TMOUT_809440743503734_145_3826941331997027" name="16_3_TMOUT_809440743503734_145_3826941331997027"></a><br />
 16.3 TMOUT<br />
 </h3>
<p>The TMOUT variable specifies the number of seconds that the Korn shell<br />
will wait for input before displaying a 60-second warning message and<br />
exiting. If not set, the default used is 0, which disables the timeout<br />
feature. To set a 10-minute timer, set TMOUT to 600:<br />
<span style="font-family:Courier New;">    $ TMOUT=600</span><br />
 This variable is usually set by the system administrator in the <span style="font-family:Courier New;">/etc/profile</span> file.
</div>
<p></span></span></p>
<h3><a id="16_4_MAILCHECK_687330215443556" name="16_4_MAILCHECK_687330215443556"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.4 MAILCHECK</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The<br />
MAILCHECK variable specifies how often, in seconds, to check for new<br />
mail. If not set, or set to zero, new mail is checked before each new<br />
prompt is displayed. Otherwise, the default setting is 600 seconds (10<br />
minutes).</p>
<p></span></span></p>
<h3><a id="16_5_MAIL_7713528906556307_892_6743312418053198" name="16_5_MAIL_7713528906556307_892_6743312418053198"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.5 MAIL</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The <b>MAIL</b> variable contains the name of a single mailbox file to check for new mail. It is not used if MAILPATH is set.</p>
<p></span></span></p>
<h3><a id="16_6_MAILPATH_3551441223568878" name="16_6_MAILPATH_3551441223568878"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.6 MAILPATH</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The<br />
MAILPATH variable contains a colon-separated list of mailbox files to<br />
check for new mail and is used if you want to read multiple mailboxes.<br />
It overrides the MAIL variable if both are set. This MAILPATH setting<br />
specifies to check two mailbox files, <span style="font-family:Courier New;">/home/anatole/mbox and /news/mbox</span>.<br />
<span style="font-family:Courier New;">    $ print $MAILPATH</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    MAILPATH=/home/anatole/mbox:/news/mbox</p>
<p></span>Just<br />
so you don't think you can go snooping around someone else's mailbox,<br />
this only works if you have read permission on the mailbox file.<br />
 If MAILPATH is not set, there is no default.</p>
<p></span></span></p>
<h3><a id="_16_7_TERM_9189810912229358_5009562197822405" name="_16_7_TERM_9189810912229358_5009562197822405"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"> 16.7 TERM </span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The<br />
TERM variable specifies your terminal type, and is usually set by your<br />
system administrator in the global /etc/profile file. If it's not set<br />
there, then it's probably in your ~/.profile file.</p>
<p></span></span></p>
<h3><a id="16_8_Enabling_Disabling_Option_48916886920819536" name="16_8_Enabling_Disabling_Option_48916886920819536"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.8 Enabling/Disabling Options</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">Korn shell options are enabled with the <b>set -o</b><i>option</i> or <b>set</b> -<i>option</i> command. For example, the noglob option disables file name substitution and can be set using either of these commands :<br />
<span style="font-family:Courier New;">    $ set —f</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Verdana;">or</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ set —o noglob</span><br />
Options can also be enabled by specifying them on the ksh command line.<br />
Here, a Korn subshell is started with the emacs option enabled:<br />
<span style="font-family:Courier New;">    $ ksh —o emacs</span><br />
 Options can be disabled with the <span style="font-family:Georgia;"><b>set +o</b> <i>option</i></span> or <b>set</b> +<i>option</i> command. In this example, the noglob option is disabled:<br />
<span style="font-family:Courier New;">    $ set +o noglob</span></p>
<p></span></span></p>
<h3><a id="16_9_Displaying_the_Current_Se_47245364006423674" name="16_9_Displaying_the_Current_Se_47245364006423674"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.9 Displaying the Current Settings</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The setting of the current options is displayed with the <b>set -o </b>command.</p>
<div id="kt4h" style="padding:1em 0;text-align:center;">
<a href="http://docs.google.com/File?id=dd6nw3mt_1728crddqft_b" target="_blank"><img src="http://docs.google.com/File?id=dd6nw3mt_1728crddqft_b" style="width:455px;height:734px;" /></a>
</div>
<p>
</span></span></p>
<h3><a id="16_10_Aliases_3822333845613286_08960525051202617" name="16_10_Aliases_3822333845613286_08960525051202617"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.10 Aliases</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">Aliases<br />
are command name macros used as shorthand for other commands,<br />
especially frequently used ones. This saves a lot of typing time.<br />
Aliases are defined with the alias name=value<br /> command.Make sure to<br />
enclose the value in quotes if it contains whitespace. Here we create<br />
an alias l that is set to the ls -Fac command:<br />
<span style="font-family:Courier New;">    $ alias l="ls —Fac"</span><br />
 Now when you type in l,<span style="font-family:Courier New;"> ls -Fac</span> is executed:<br />
<span style="font-family:Courier New;">    $ l</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    ./</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    ../</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    compress.Z*</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    func.Z*</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    test/</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    uncompress.Z*</span><br />
<span style="font-family:Courier New;">    . . .</span></p>
<p> Alias values can contain any text, including special characters, like wild-cards, pipes, or I/O redirection operators.</p>
<p> Here we set two aliases: p and h. When invoked, we get h instead of Hello.<br />
<span style="font-family:Courier New;">    $ alias p='print' h=Hello</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ p h</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    h</span><br />
 After the p alias is reset with a trailing blank, h gets substituted in the next command correctly:<br />
<span style="font-family:Courier New;">    $ alias p='print ' h=Hello</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ p h</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Hello</span></p>
<p></span></span></p>
<h4><a id="16_10_1_Displaying_Current_Ali" name="16_10_1_Displaying_Current_Ali"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.10.1 Displaying Current Aliases</span></span><br />
</h4>
<h4>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">A list of the current aliases is displayed using the <b>alias</b> command without arguments.</p>
<p></span></span></p>
<h4><a id="16_10_2_Removing_Aliases_26645" name="16_10_2_Removing_Aliases_26645"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">16.10.2 Removing Aliases</span></span><br />
</h4>
<h4>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">Aliases are removed with the<b> unalias</b> command. Let's try it with the l alias:<br />
<span style="font-family:Courier New;">    $ unalias l</span></p>
<p></span></span></p>
<h2><a id="17_Korn_Shell_Scripts_48337193" name="17_Korn_Shell_Scripts_48337193"></a><br />
<i><span style="font-family:'Courier New';"><span style="font-family:Verdana;">17 Korn Shell Scripts</span></span></i><br />
</h2>
<h2>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h2>
<h3><a id="17_1_Positional_Parameters_109" name="17_1_Positional_Parameters_109"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.1 Positional Parameters</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">Positional<br />
parameters are special variables used to keep track of arguments to the<br />
Korn shell, scripts, and functions. Positional parameter names contain<br />
only digits and cannot be set directly using <i>variable=value</i> syntax. By default, parameter zero (or $0) is set to the name of the shell, script or function.<br />
<span style="font-family:Courier New;">    $ print $0</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    /bin/ksh</span><br />
The remaining parameters 1 to n are set to each of the arguments passed<br />
to the shell, script or function. For example, if you invoke a Korn<br />
shell script called <b>ptest</b> and pass the arguments <b>A</b>, <b>B</b>, and <b>C</b>, then in the script ptest, <b>$0</b> would be set to <b>ptest</b>, <b>$1</b> to <b>A</b>, <b>$2</b> to <b>B</b>, and <b>$3</b> to <b>C</b>.</p>
<div id="oal2" style="padding:1em 0;text-align:left;">
<img src="http://docs.google.com/File?id=dd6nw3mt_173f7n7tvcw_b" style="width:240px;height:157px;" />
</div>
<p></p>
<div id="t7df" style="padding:1em 0;text-align:center;">
<img src="http://docs.google.com/File?id=dd6nw3mt_174pzmvjcfz_b" style="width:536px;height:541px;" />
</div>
<p>
 There are three special Korn shell variables that provide information about the current positional parameters. <u>The first is <b>$#</b>, and it contains the number of positional parameters</u>. <u>The other two are <b>$@</b> and <b>$*</b>, and they both contain all the positional parameters.</u><br />
So in the above ptest example, $# would be 3, and both $* and $@ would<br />
be A B C. Here is a Korn shell script that manipulates positional<br />
parameters. It displays the name of the current script, the number of<br />
positional parameters, and the value of each of the positional<br />
parameters:<br />
<span style="font-family:Courier New;">    $ cat check_params</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Script name: $0"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Number of args passed: $#"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Arguments passed: $*"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Arg 1=$1, Arg 2=$2, Arg 3=$3"</span></p>
<p></span></span></p>
<h3><a id="17_2_Modifying_Positional_Para" name="17_2_Modifying_Positional_Para"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.2 Modifying Positional Parameters</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">By default, <b>$0</b> is set to the name of the shell, script or function. It cannot be set or modified. The remaining parameters from <b>$1</b> to<b> $n</b> can be reassigned with the<span style="color:rgb(0,0,255);"> </span><b>shift</b><br />
command. The shift command, with no arguments, shifts positional<br />
parameters left once, so that $1 takes the value of $2, $2 takes the<br />
value of $3, and so on. <u>The original value of $1 is lost.<br />
</u> <u><br />
</u>Let's change the check_params script so that it shifts the positional<br />
 parameters left once:<br />
<span style="font-family:Courier New;">    $ cat check_params</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Script name: $0"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Number of args passed: $#"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Arguments passed: $*"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Arg 1=$1, Arg 2=$2, Arg 3=$3"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    shift</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Number of remaining args: $#"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Remaining args: $*"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    print "Arg 1=$1, Arg 2=$2, Arg 3=$3"</span><br />
 When we run it again with the arguments A B:<br />
<span style="font-family:Courier New;">    $ check_params A B</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Script name: check_params</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Number of args passed: 2</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Arguments passed: A B</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Arg 1=A, Arg 2=B, Arg 3=</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Number of remaining args: 1</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Remaining args: B</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    Arg 1=B, Arg 2=, Arg 3=</span><br />
 After the shift command, $1 is set to B and $2 is unset. The original value of $1 is lost.</p>
<p> The positional parameters can be shifted left more than once by providing an integer argument to the <b>shift</b> command: <b><span style="font-family:Georgia;">shift <i>n</i></span></b>.</p>
<p></span></span></p>
<h3><a id="17_3_The_exit_command_23414194" name="17_3_The_exit_command_23414194"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.3 The exit command</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The <b>exit</b> command allows you to terminate execution from anywhere in a Korn shell script and return an <b>exit</b> value using this format:<br />
<b>        exit</b><br />
 or<br />
<b>        exit <i>n</i></b><br />
 where <i>n</i> is the exit status to return. <u>If n is not specified, the exit status of the previous command is used</u>. If you don't use exit, then scripts finish after the last command is executed.</p>
<p></span></span></p>
<h3><a id="_17_4_The_Command__5899032850007576" name="_17_4_The_Command__5899032850007576"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.4 The [[...]] Command</span></span><br />
</h3>
<h3>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The<br />
[[...]] command is used to evaluate conditional expressions with file<br />
attributes, strings, integers, and more. The basic format is:<br />
         <b>[[</b><i><b> </b><span style="font-family:Georgia;">expression</span></i> <b>]]</b><br />
 where </span></span><span style="font-family:Courier New;"><span style="font-family:Verdana;"><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><i><span style="font-family:Georgia;">expression</span></i></span></span></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
is the condition you are evaluating. There must be whitespace after the<br />
opening brackets, and before the closing brackets. Whitespace must also<br />
separate the expression arguments and operators. For example, these are<br />
incorrect:<br />
<span style="font-family:Courier New;">    [[$X=$Y]]</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    [[$X = $Y]]</span><br />
 while this is correct:<br />
<span style="font-family:Courier New;">    [[ $X == $Y ]]</span><br />
 Notice that there is white space between $X, $Y, and the = operator.</p>
<p>If the expression evaluates to true, then a zero exit status is<br />
returned, otherwise the expression evaluates to false and a non-zero<br />
exit status is returned.</p>
<p> If you are familiar with the<b> test</b> and <b>[...]</b><br />
commands, then you'll recognize that [[...]] is just a new and improved<br />
version of the same commands. It basically functions the same way,<br />
except that a number of new operators are available.<br />
</span></span>
</div>
<div id="yn69" style="padding:1em 0;text-align:left;">
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></p>
<div id="t5_z" style="padding:1em 0;text-align:center;">
</div>
<p></span></span></p>
<div style="text-align:center;">
<div style="text-align:left;">
<h4><a id="_17_4_1_Checking_Strings__5241385150842537" name="_17_4_1_Checking_Strings__5241385150842537"></a><br />
 17.4.1 Checking Strings<br />
 </h4>
</div>
<p>
</div>
<div style="text-align:center;">
<span style="font-family:Courier New;"><span style="font-family:Verdana;"><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><a href="http://docs.google.com/File?id=dd6nw3mt_175gwrn86d5_b" target="_blank"><img src="http://docs.google.com/File?id=dd6nw3mt_175gwrn86d5_b" style="width:507px;height:459px;" /></a></span></span></span></span></p>
<div style="text-align:left;">
We could use the [[...]] command to check if a variable is set to a<br />
certain value. Here, variable X is assigned abc, then evaluated in this<br />
expression:<br />
<span style="font-family:Courier New;">    $ X=abc</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ $X = abc ]] &amp;&amp; print "X is set to abc"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    X is set to abc</span>
</div>
<div style="text-align:left;">
 Using the test and [...] commands, the same command could be written as:<br />
<span style="font-family:Courier New;">    test "$X" = abc &amp;&amp; print "X is set to abc"</span><br />
 or<br />
<span style="font-family:Courier New;">    [ "$X" = abc ] &amp;&amp; print "X is set to abc"</p>
<p></span>To check if a variable is set to null, the -z option can be used:<br />
<span style="font-family:Courier New;">    [[ —z $VAR ]] &amp;&amp; print "VAR is set to null"</span><br />
 or it could be compared to the null string like this:<br />
<span style="font-family:Courier New;">    [[ $VAR = "" ]] &amp;&amp; "VAR is set to null"</span>
</div>
</div>
<p><span style="font-family:'Courier New';"></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
</span></span></p>
<h4><a id="_17_4_2_Checking_Patterns__24458779692309196" name="_17_4_2_Checking_Patterns__24458779692309196"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.4.2 Checking Patterns</span></span><br />
</h4>
<h4>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The Korn shell also lets you compare strings to patterns. We could check if X begins with a 'a' like this:<br />
<span style="font-family:Courier New;">    $ X=abc</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ $X = a* ]] &amp;&amp; print "$X matches a*"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    abc matches a*</span></p>
<p> Using the +([09]) pattern, we could check if X is set to a number:<br />
<span style="font-family:Courier New;">    $ X=123</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ $X = +([0—9]) ]] &amp;&amp; print "$X is a number"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    123 is a number</span></p>
<p></span></span></p>
<h4><a id="_17_4_3_Checking_File_Attribut_4279807512566526" name="_17_4_3_Checking_File_Attribut_4279807512566526"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.4.3 Checking File Attributes</span></span><br />
</h4>
<h4>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></p>
<div id="f9e-" style="padding:1em 0;text-align:center;">
<img src="http://docs.google.com/File?id=dd6nw3mt_176d9kt7dg6_b" style="width:432px;height:572px;" /></p>
</div>
<p></span></span></p>
<div style="text-align:left;">
 The most basic operation to perform on a file is to see if it exists, and that can be done using the -a operator.<br />
<span style="font-family:Courier New;">    $ touch tmp</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ —a tmp ]] &amp;&amp; print "File tmp exists"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    File tmp exists</span></p>
<p>This only indicates that it exists, but not much else. It may be a<br />
directory, or a symbolic link, but using this operator, that's all we<br />
know. If we wanted more information, the -f or -d operators could tell<br />
us if a file existed and was a regular file (-f) or if it was just a<br />
directory (-d).</p>
<h4><a id="_17_4_4_Checking_Integer_Attri_07001292456862485" name="_17_4_4_Checking_Integer_Attri_07001292456862485"></a><br />
 17.4.4 Checking Integer Attributes<br />
</h4>
<div id="q-dl" style="padding:1em 0;text-align:center;">
<a href="http://docs.google.com/File?id=dd6nw3mt_177frb3r2c8_b" target="_blank"><img src="http://docs.google.com/File?id=dd6nw3mt_177frb3r2c8_b" /></a>
</div>
<p>
The [[...]] command provides a few integer operators that allow<br />
integers to be compared. It is frequently used to check the number of<br />
command-line arguments. This expression evaluates to true if there are<br />
less than or equal to three positional parameters set:<br />
 [[ $# —le 3 ]] &amp;&amp; print "3 or less args given"
</div>
<p><span style="font-family:'Courier New';"></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
The ((...)) command offers the same arithmetic comparison operators as<br />
the [[...]] command, plus many others. Besides offering more arithmetic<br />
operators, the ((...)) command provides substantial performance<br />
improvements over the [[...]] and test commands.</p>
<p></span></span></p>
<h4><a id="_17_4_5_The_Operator__42667919512565855" name="_17_4_5_The_Operator__42667919512565855"></a><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.4.5 The ! Operator</span></span><br />
</h4>
<h4>
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span><br />
</h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The ! operator negates the result of any [[...]] expression when used like this:<br />
<b><span style="font-family:Georgia;">[[ ! <i>expression</i> ]]</span></b><br />
 For example, to check if X is not equal to abc:<br />
<span style="font-family:Courier New;">    $ X=xyz</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ ! $X = abc ]] &amp;&amp; print "$X not equals abc"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    xyz not equals abc</span></p>
<p>There is one logical operator that can only be implemented with the !<br />
operator. There is no [[...]] file operator that will evaluate to true<br />
on a zero-length file.<br />
<span style="font-family:Courier New;">    $ &gt;emptyfile</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    $ [[ ! —s emptyfile ]] &amp;&amp; print "emptyfile is empty"</span><br style="font-family:Courier New;" /><br />
<span style="font-family:Courier New;">    emptyfile is empty</span></p>
<p></span></span><br />
<h4><a id="_17_4_6_Compound_Expressions_47728179982164753" name="_17_4_6_Compound_Expressions_47728179982164753"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
 17.4.6 Compound Expressions</span></span></h4>
<h4><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
</span></span></h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">
<div id="l2r." style="padding:1em 0;text-align:center;"><img src="http://docs.google.com/File?id=dd6nw3mt_179fq89jwhp_b" />
<div style="text-align:left;"><span style="font-family:'Courier New';"><span style="font-family:Verdana;">(1) <b>&amp;&amp;</b> - The AND Operator<br /></span></span>The &amp;&amp; operator is used with the [[...]] command to test if multiple expressions are true using this format:<br /><span style="font-family:Courier New;">    [[ expression1 &amp;&amp; expression2 ]]</span></div>
</div>
<p></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
 This expression checks if the noglob and noclobber options are set:<br /><span style="font-family:Courier New;">    [[ —o noglob &amp;&amp; —o noclobber ]]</span></p>
<p>(2) <b>||</b> - The OR Operator<br />The | | operator is used with the [[...]] command to test if expression1 OR expression2 are true using this format:<br /><span style="font-family:Courier New;">    [[ expression1 | | expression2 ]]</span></p>
<p></span></span><br />
<h4><a id="17_4_7_vs_test_and__7445772201941858" name="17_4_7_vs_test_and__7445772201941858"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">17.4.7 [ [...] ] vs test and [...]</span></span></h4>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The [[...]] command is preferred to test and [...], since many of the errors associated with test and [...] do not occur.</p>
<p></span></span><br />
<h2><a id="_18_Control_Commands" name="_18_Control_Commands"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br />
<i>18 Control Commands</i></span></span></h2>
<h2><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span></h2>
<h3><a id="18_1_The_case_command" name="18_1_The_case_command"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.1 The case command</span></span></h3>
<h3><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span></h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The case command provides multiple-branch capability. The syntax for the case command is:
<div id="of:d" style="padding:1em 0;text-align:left;"><img style="width:401px;height:251px;" src="http://docs.google.com/File?id=dd6nw3mt_180dxmkc4d8_b" /><br />where value is compared to <i>pattern1, pattern2, ... patternn</i>.</p>
<p>The<br />
same patterns used in file name substitution can also be used in case<br />
statements to match patterns. The new Korn shell pattern matching<br />
formats also allow multiple case patterns to be given like this:
<div id="p2_e" style="padding:1em 0;text-align:center;"><img style="width:613px;height:396px;" src="http://docs.google.com/File?id=dd6nw3mt_181fghtsb7m_b" /></div>
<h3><a id="18_2_The_for_Command" name="18_2_The_for_Command"></a>18.2 The for Command</h3>
<p>The basic syntax for the for command is:<br /><b><span style="font-family:Georgia;">        for </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> in </span></b><i><span style="font-family:Georgia;">word1  word2 . . . wordn</span></i><b><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        do</span><br style="font-family:Georgia;" /><span style="font-family:Georgia;">                   </span></b><span style="font-family:Georgia;"><i> </i><i>commands</i></span><b><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        done</span></b></div>
<p>File name substitution, command substitution, and variable substitution<br />
can also be used to generate a list of word arguments for the for<br />
command. The first line of the previous command could have been given<br />
as:<br /><span style="font-family:Courier New;">    for FILE in chap[1-3]</span><br />or<br /><span style="font-family:Courier New;">    for FILE in $(ls chap[1-3])</span><br />or<br /><span style="font-family:Courier New;">    CHAPS=$(ls chap[1-3])</span><br /><span style="font-family:Courier New;">    for FILE in $CHAPS</p>
<p></span>The <b>$* </b>and <b>$@</b> variables can be used to loop on command-line arguments like this:<br /><b><span style="font-family:Georgia;">        for </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> in $*</span><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        do</span><br style="font-family:Georgia;" /></b><i><span style="font-family:Georgia;">                commands</span></i><b><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        done</span></b></p>
<p>The for command can also be used without the list of word arguments:<br /></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;">        for </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> </span><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;">        do</span><br style="font-family:Georgia;" /><br />
</b><i><span style="font-family:Georgia;">                commands</span></i><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;">        done</span></b></span></span><br /><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The commands are executed once for each positional parameter, and <i>variable</i> is set to each successive positional parameter. It is equivalent to:<br /></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;">       for </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> in $@</span><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;">        do</span><br style="font-family:Georgia;" /><br />
</b><i><span style="font-family:Georgia;">                commands</span></i><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;">        done</span></b></p>
<p></span></span><br />
<h3><a id="18_3_The_if_Command" name="18_3_The_if_Command"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.3 The if Command</span></span></h3>
<h3><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span></h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The basic syntax of the if command is:<br /><b><span style="font-family:Georgia;">        if </span></b><span style="font-family:Georgia;"><i>command1</i></span><b><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        then</span><br style="font-family:Georgia;" /><span style="font-family:Georgia;">                </span></b><i><span style="font-family:Georgia;">commands</span></i><b><br style="font-family:Georgia;" /><span style="font-family:Georgia;">        </span></b></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;">elif </span></b><span style="font-family:Georgia;"><i>command2<br />        </i></span></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;"> then</span></b></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><span style="font-family:Georgia;"><i><br />                commands<br /></i></span></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;">        else<br />                </span></b></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><i><span style="font-family:Georgia;">commands</span></i></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;"><br />        fi</span></b><br />
</span></span><br />
<h3><a id="18_4_The_while_Command" name="18_4_The_while_Command"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.4 The while Command</span></span></h3>
<h3><a id="_while_command1_do_commands_do" name="_while_command1_do_commands_do"></a><span style="font-family:'Courier New';"><font size="2">        while <i>command1</i><br />        do<br />                <i>commands</i><br />        done</font><span style="font-family:Verdana;"></span></span></h3>
<h3><a id="18_5_The_until_Command" name="18_5_The_until_Command"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.5 The until Command</span></span></h3>
<h3><a id="The_until_command_is_another_l" name="The_until_command_is_another_l"></a><span style="font-family:'Courier New';"></span></h3>
<h3><span style="font-family:'Courier New';"><font size="2">The<br />
until command is another looping command. It's like the while command,<br />
except that instead of looping while the condition is true, it loops<br />
while the condition is false. The syntax for the until command is:<br /><b>        until </b><i><span style="font-family:Georgia;">command1</span></i><b><br />        do<br />                </b><i><span style="font-family:Georgia;">commands</span></i><b><br />        done</b><br />where commands are executed until command1 returns a zero exit status.</font><span style="font-family:Verdana;"></span></span></h3>
<h3><a id="18_6_Breaking_Out_of_Loops" name="18_6_Breaking_Out_of_Loops"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.6 Breaking Out of Loops</span></span></h3>
<h3><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span></h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b>break</b> command  causes an exit from a loop-type command, but not from the entire script.</p>
<p>The break command can also be used to exit from a nested loop using this format:<br /><b>        break </b><span style="font-family:Georgia;"><i>n</i></span><br />where </span></span><u><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b> </b><span style="font-family:Georgia;"><i>n</i></span></span></span></u><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><u> specifies the <i>n</i>th enclosing loop to exit from</u>.<br />Here is a new version of the nloop script that breaks out of both loops if i equals 2 and j equals 0:<br /><span style="font-family:Courier New;">$ cat nloop</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">for i in 1 2 3</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">do</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">    for j in 0 5</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">    do</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">        if ((i == 2 &amp;&amp; j == 0))</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">        then</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">            break 2</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">        else</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">            print "$i$j"</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">        fi</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">    done</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">done</span></p>
<p>Now the output would be:<br /><span style="font-family:Courier New;">    $ nloop</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">    10</span><br style="font-family:Courier New;" /><span style="font-family:Courier New;">    15</span><br />If<br />
break was used instead of break 2, then only the inner for loop would<br />
have been terminated, and execution would have continued with i set to<br />
3 in the outer loop, and j set to 0 in the inner loop.</p>
<p></span></span><br />
<h3><a id="18_7_The_continue_Command" name="18_7_The_continue_Command"></a><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.7 The continue Command</span></span></h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The <b>continue</b> command causes execution to continue at the top of the current loop.</p>
<p>18.8 The select Command<br />The <b>select </b>command<br />
is used to display a simple menu that contains numbered items, and a<br />
prompt message. The syntax for the select command is:</p>
<p><b>        select </b><span style="font-family:Georgia;"><i>variable </i></span><b>in </b><i><span style="font-family:Georgia;">word1 word2 . . . wordn</span></i><b><br />        do<br />                </b><span style="font-family:Georgia;"><i>commands</i></span><b><br />        done</b><br />where <i>word1</i> through <i>wordn</i> are displayed as numbered menu choices followed by a prompt (default #?). </p>
<p><u>If the response is in the range 1 through n, then <i>variable</i> is set to the corresponding word, <b>REPLY</b> is set to the response, and the commands are executed.</u> Execution continues until a break, exit, return, or EOF is encountered.</p>
<p></span></span></p>
<h3><span style="font-family:'Courier New';"><span style="font-family:Verdana;">18.8 The select Command</span></span></h3>
<h3><span style="font-family:'Courier New';"><span style="font-family:Verdana;"></span></span></h3>
<p><span style="font-family:'Courier New';"><span style="font-family:Verdana;">The<br />
select command is used to display a simple menu that contains numbered<br />
items, and a prompt message. The syntax for the select command is:</p>
<p><b><span style="font-family:Georgia;"><span>    </span><span>    </span>select </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> in </span></b><span style="font-family:Georgia;"><i>word1 word2 . . . wordn</i></span><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>do</span><br style="font-family:Georgia;" /><br />
</b><i><span style="font-family:Georgia;"><span>    </span><span>    </span><span>    </span><span>    </span>commands</span></i><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>done</span></b></p>
<p>where <i>word1</i> through <i>wordn </i>are displayed as numbered menu choices followed by a prompt (default #?). If the response is in the range 1 through n, then <i>variable</i> is set to the corresponding word, <b>REPLY</b> is set to the response, and the <i>commands</i> are executed. Execution continues until a <b>break</b>, <b>exit</b>, <b>return</b>, or <b>EOF</b> is encountered.</p>
<p>The <b>select</b> command can also be used without the list of word arguments:</p>
<p></span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;"><span>   </span><span>    </span>select </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> </span></b><span style="font-family:Georgia;"><i></i></span><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>do</span><br style="font-family:Georgia;" /><br />
</b><i><span style="font-family:Georgia;"><span>    </span><span>    </span><span>    </span><span>    </span>commands</span></i><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>done</span></b></span></span><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;">It<br />
functions the same way as the previous select syntax, except that the<br />
positional parameters are displayed as numbered menu choices from 1 to<br />
n, instead of the words from the word list. It is equivalent to:<br />
</span></span><span style="font-family:'Courier New';"><span style="font-family:Verdana;"><b><span style="font-family:Georgia;"><span>   </span><span>    </span>select </span></b><span style="font-family:Georgia;"><i>variable</i></span><b><span style="font-family:Georgia;"> in </span></b><span style="font-family:Georgia;"><i>"$@"</i></span><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>do</span><br style="font-family:Georgia;" /><br />
</b><i><span style="font-family:Georgia;"><span>    </span><span>    </span><span>    </span><span>    </span>commands</span></i><b><br style="font-family:Georgia;" /><br />
<span style="font-family:Georgia;"><span>    </span><span>    </span>done</span></b></span></span><br />
<span style="font-family:'Courier New';"><span style="font-family:Verdana;"><br /></span></span></div>
